# Server & Data API — Context for Claude

## What this is

FastAPI server (`bristlenose serve`) that serves a React SPA (React Router, pathname-based routes) over HTTP, provides REST API endpoints for researcher state, and stores all pipeline output + researcher edits in SQLite. In serve mode, `app.py` replaces `<!-- bn-app -->` markers in the rendered HTML with `<div id="bn-app-root">`; React Router handles all client-side navigation (tab switching, session drill-down, back/forward). The SPA catch-all route (`GET /report/{path:path}`) returns the same transformed HTML for all `/report/*` paths. Transcript HTML files from `bristlenose render` are still served directly (route defined before the catch-all for priority).

## Architecture

```
bristlenose/server/
  app.py          — FastAPI factory (create_app), dev-mode HTML injection
  db.py           — SQLAlchemy engine, session factory, SQLite with WAL + FK
  models.py       — 24 ORM tables (see docs/design-serve-milestone-1.md)
  importer.py     — Pipeline JSON → SQLite on startup (idempotent upsert)
  admin.py        — SQLAdmin browser (dev-only, /admin/)
  autocode.py     — AutoCode engine (taxonomy, batching, async job runner)
  routes/
    health.py     — GET /api/health
    sessions.py   — GET /api/projects/{id}/sessions (React sessions table, includes source_folder_uri)
    quotes.py     — GET /api/projects/{id}/quotes (quotes grouped by section/theme)
    data.py       — 12 data API endpoints (Phase 1 researcher state sync)
    autocode.py   — 7 AutoCode endpoints (start, status, proposals, accept/deny)
    dev.py        — Dev-only endpoints (visual diff, system info)
  codebook/       — YAML codebook templates (garrett, norman, uxr, plato)
  static/         — Vite build output (React Router SPA bundle)
```

## Data API (Phase 1)

The data API replaces localStorage with HTTP.  Each endpoint mirrors one localStorage key.  The vanilla JS modules call `apiPut()` after every `localStorage.setItem()` — fire-and-forget background sync.

### Endpoints

| Method | Path | localStorage key | JS module | DB tables |
|--------|------|------------------|-----------|-----------|
| GET/PUT | `/projects/{id}/people` | `bristlenose-names` | `names.js` | Person, SessionSpeaker |
| GET/PUT | `/projects/{id}/edits` | `bristlenose-edits` | `editing.js` | QuoteEdit, HeadingEdit |
| GET/PUT | `/projects/{id}/tags` | `bristlenose-tags` | `tags.js` | QuoteTag, TagDefinition |
| GET/PUT | `/projects/{id}/hidden` | `bristlenose-hidden` | `hidden.js` | QuoteState |
| GET/PUT | `/projects/{id}/starred` | `bristlenose-starred` | `starred.js` | QuoteState |
| GET/PUT | `/projects/{id}/deleted-badges` | `bristlenose-deleted-badges` | `tags.js` | DeletedBadge |

### Data flow

```
User clicks star → JS updates DOM + in-memory map
                 → localStorage.setItem() (immediate, synchronous)
                 → if (isServeMode()) apiPut('/starred', map) (async, fire-and-forget)
                                        ↓
                                   FastAPI route
                                        ↓
                                   SQLite upsert
```

**localStorage remains the source of truth** for the current page session.  The API is a background sync — if it fails, a toast shows but no rollback occurs.

### Serve-mode detection

The server injects `<script>window.BRISTLENOSE_API_BASE = '/api/projects/1';</script>` into the HTML at serve time (`app.py:_mount_dev_report`).  When absent (static HTML opened from disk), `isServeMode()` returns false and all API calls are silently skipped.

### Quote DOM ID ↔ DB mapping

The static HTML uses DOM IDs like `q-p1-123` (format: `q-{participant_id}-{int(start_timecode)}`).  The API accepts these DOM-style IDs and resolves them server-side:

- **`_parse_dom_quote_id("q-p1-123")`** → `("p1", 123)`
- **`_resolve_quote(db, project_id, "q-p1-123")`** → queries `Quote` where `participant_id="p1"` and `start_timecode` is in `[123, 124)` (the `int()` truncation means we need a range match)

This is in `routes/data.py`.  The same format is generated by `render_html.py` (`f"q-{quote.participant_id}-{int(quote.start_timecode)}"`).

### Bulk maps, not individual PATCH

All endpoints use GET/PUT of full state maps (not per-item PATCH).  This matches the localStorage pattern — each `set()` writes the entire JSON blob.  Tradeoff: larger payloads but simpler migration diff and no partial-state bugs.

### Tag definitions

User-defined tags auto-create `TagDefinition` rows.  New tags are assigned to an "Ungrouped" `CodebookGroup` (auto-created if needed by `_get_or_create_ungrouped()`).  The codebook UI can later reassign them to real groups.

### Hidden + Starred share QuoteState

Both `is_hidden` and `is_starred` live on the same `QuoteState` row (one per quote).  The PUT endpoints update only their respective field — they don't clobber each other.

## api-client.js

The JS-side HTTP abstraction (`bristlenose/theme/js/api-client.js`).  Loaded second in `_JS_FILES` (after `storage.js`, before everything else).

- **`isServeMode()`** — `typeof BRISTLENOSE_API_BASE === 'string'`
- **`apiGet(path)`** — fetch GET, returns JSON or null on error
- **`apiPut(path, data)`** — fetch PUT with JSON body, shows toast on error via `showToast()` (optional dependency from `csv-export.js`)

All calls are **fire-and-forget promises**.  The JS modules don't `await` them.

## Patterns to follow

### Adding a new data endpoint

1. Add the route to `routes/data.py` — follow `get_hidden`/`put_hidden` as the simplest template
2. Use `_get_db(request)`, `_check_project()`, `try/finally db.close()`
3. For quote-keyed data: use `_resolve_quote()` and `_quote_dom_id()` to translate between DOM IDs and DB rows
4. Add tests in `tests/test_serve_data_api.py` — the `client` fixture gives you a TestClient with the smoke-test data pre-imported (4 quotes: `q-p1-10`, `q-p1-26`, `q-p1-46`, `q-p1-66`)
5. If the JS needs to call it: add `if (isServeMode()) apiPut(...)` after the corresponding `store.set()` call

### Adding a new JS module that syncs state

1. Add `isServeMode, apiPut` to the `/* global ... */` comment
2. After every `yourStore.set(data)` call, add: `if (isServeMode()) apiPut('/your-endpoint', data);`
3. That's it.  `apiPut` prepends `BRISTLENOSE_API_BASE` internally — **never** add the base URL at the call site (double-prefix bug)

### DB dependency injection

```python
def _get_db(request: Request) -> Session:
    return request.app.state.db_factory()
```

The factory is stored on `app.state` during `create_app()`.  Each route creates its own session and **must close it** in a `finally` block.

## React island integration

React islands replace static Jinja2 content at serve time using a **marker-based substitution** pattern. No changes to the render pipeline or Jinja2 templates beyond adding comment markers.

### How it works

1. **Render time** (`render_html.py`): wraps content regions in comment markers:
   ```html
   <!-- bn-quote-sections -->
   <section>...Jinja2 content...</section>
   <!-- /bn-quote-sections -->
   ```

2. **Serve time** (`app.py:serve_report_html()`): regex replaces marker regions with React mount divs:
   ```html
   <!-- bn-quote-sections -->
   <div id="bn-quote-sections-root" data-project-id="1"></div>
   <!-- /bn-quote-sections -->
   ```

3. **Browser**: React `main.tsx` finds `#bn-quote-sections-root`, calls `createRoot().render(<QuoteSections />)`

### Current React islands

| Mount point | Component | Markers | API endpoint |
|------------|-----------|---------|-------------|
| `#bn-sessions-table-root` | `SessionsTable` | `bn-session-table` | `GET /api/projects/{id}/sessions` |
| `#bn-quote-sections-root` | `QuoteSections` | `bn-quote-sections` | `GET /api/projects/{id}/quotes` |
| `#bn-quote-themes-root` | `QuoteThemes` | `bn-quote-themes` | `GET /api/projects/{id}/quotes` |
| `#bn-about-developer-root` | `AboutDeveloper` | (created by JS) | `GET /api/dev/info` |

### Adding a new React island

1. Add `<!-- bn-{name} -->` / `<!-- /bn-{name} -->` markers in `render_html.py`
2. Add `_REACT_{NAME}_MOUNT` constant in `app.py` with the mount div
3. Add `re.sub()` call in `serve_report_html()` to swap markers for mount div
4. Register the mount point in the renderer overlay CSS (4 places: `position:relative`, `:not(:has())` exclusions, cancel-inside-React, green overlay+outline)
5. Add mount logic in `frontend/src/main.tsx`
6. Re-render the report (`bristlenose render`) to bake in the new markers

### Renderer overlay (dev-only)

The `_build_renderer_overlay_html()` function injects CSS that colour-codes the page by renderer origin:
- **Blue** — Jinja2 (static pipeline HTML)
- **Green** — React islands
- **Amber** — Vanilla JS regions (codebook grid, analysis)

Toggle with the palette button in the top-right corner. When adding a new React island, register it in all 4 CSS blocks (see step 4 above) or it will show as blue instead of green.

## Dev loop (live JS reload)

In dev mode (`bristlenose serve --dev`), the server **live-reloads JS on every request**.  You can edit any `.js` file in `bristlenose/theme/js/`, refresh the browser, and see the change immediately — no `bristlenose render` step needed.

How it works: `serve_report_html()` reads the baked-in HTML from disk, finds the `/* bristlenose report.js */` marker, and replaces everything from there to the IIFE closing `})();` with freshly-read source files via `_load_live_js()` (which imports `_JS_FILES` from `render_html.py` for the canonical dependency order).  All vanilla JS modules are loaded — the toolbar init functions (`initSearchFilter`, `initViewSwitcher`, etc.) harmlessly no-op because the React Toolbar island replaces their DOM targets.  The IIFE wrapper `(function() { ... })();` is part of the Jinja2 template — the replacement must preserve the closing or **all JS init functions silently fail to run** (no console error, just a dead page).

**What still requires re-render:** changes to the Jinja2 HTML template itself (not JS), changes to CSS files, changes to data variables (quote map, analysis data).  JS changes are live.

**Python changes** are handled by uvicorn's `--reload` (WatchFiles) — editing `data.py`, `app.py`, etc. triggers an automatic server restart.

## Names architecture (YAML canonical, DB materialized)

`people.yaml` is the single source of truth for participant names. The SQLite `Person` table is a materialized view, populated from YAML on import and kept in sync via write-through.

### Import path (YAML → DB)

`_import_speakers()` in `importer.py` reads `people.yaml` via `_load_people_for_import()` and populates `Person.full_name`, `short_name`, `role_title`, `persona`, `notes` from matching entries. On re-import (server restart), `_update_persons_from_people()` fills empty Person fields from YAML without overwriting non-empty values — so browser edits (via `PUT /people`) always win over YAML.

### Write-through path (DB → YAML)

`PUT /people` in `routes/data.py` writes to DB first (for UI responsiveness), then calls `_write_through_people_yaml()` which atomically updates `people.yaml` (tempfile + rename). This means pipeline re-runs see browser edits. Write-through is best-effort — if it fails, a warning is logged but the API still succeeds.

### Lifecycle

```
Pipeline run → people.yaml (names from LLM/labels/manual edit)
                    ↓
bristlenose serve → importer reads YAML → Person rows in DB
                    ↓
Browser edit → PUT /people → DB (immediate) + YAML (atomic write-through)
                    ↓
Pipeline re-run → reads YAML → sees browser edits → preserves them
```

### International names (`_extract_given_name` in people.py)

`suggest_short_names()` uses `_extract_given_name()` which handles:
- **CJK ideographic** (田中由紀) — uses full name as short name (no splitting)
- **Honorific prefixes** (Dr., Prof.) — strips via `_strip_honorific()` before taking first token
- **Family-first names** (Tanaka Yuki, Park Ji-hyun) — checks first token against `_FAMILY_FIRST_SURNAMES` (337 entries), takes second token if matched
- Everything else — first token heuristic (works for Western, Spanish double surname, Russian patronymic, Arabic, mononym)

Known false positive: westernized order "Wei Zhang" (where "Wei" is also in `_FAMILY_FIRST_SURNAMES`) flips incorrectly. Acceptable — researcher corrects via inline edit.

## Gotchas

- **Quote timecode range match** — DOM ID uses `int(start_timecode)` which truncates.  A quote at 123.45s becomes `q-p1-123`.  The resolver queries `start_timecode >= 123 AND start_timecode < 124` to handle this
- **PUT replaces entire state** — PUT `/hidden` with `{}` unhides everything.  PUT `/tags` with `{}` deletes all tags.  This is intentional (mirrors localStorage `setItem`)
- **TagDefinition foreign key** — `codebook_group_id` is non-nullable.  New tags go to the "Ungrouped" group.  Don't use `codebook_group_id=0` — it violates the FK constraint
- **`Session` name collision** — SQLAlchemy's `Session` (the DB session) clashes with the `Session` model.  Import the model as `SessionModel`: `from bristlenose.server.models import Session as SessionModel`
- **`db.close()` in finally** — every route must close its session.  Leaking sessions exhausts the SQLite connection pool
- **Project ID is always 1** — the current server only loads one project at startup.  `BRISTLENOSE_API_BASE` is hardcoded to `/api/projects/1`.  Multi-project support is future work
- **Offline graceful degradation** — static HTML files (opened from disk, not served) have no `BRISTLENOSE_API_BASE` global.  `isServeMode()` returns false, all API calls skip silently, localStorage works as before
- **No `await` on API calls** — the JS modules fire `apiPut()` without awaiting.  This means rapid clicks send multiple overlapping PUTs.  The server handles this safely because each PUT replaces the full state (last writer wins)
- **Ruff ignores JS files** — `ruff check .` skips `.js` files.  Don't pass JS files to ruff directly (it tries to parse them as Python and generates hundreds of false errors)
- **IIFE wrapper around the script block** — `render_html.py` wraps data variables + concatenated JS in `(function() { ... })();`.  The live JS reload (`_replace_baked_js`) must use `rfind("})();")` to preserve the closing.  If you break the IIFE, every init function silently fails — tabs stop working, stars don't toggle, nothing interactive works, but there's **no console error** because the JS simply never executes
- **Baked HTML requires re-render to pick up new JS** — the static HTML report on disk contains a snapshot of the JS from the last `bristlenose render`.  In production (no `--dev`), editing `.js` source files has no effect until you re-render.  The live reload only works in `--dev` mode.  If something works in dev but not in the static file, the static file is stale
- **`pip install -e .` and render are separate steps** — an editable install makes Python changes visible immediately, but the rendered HTML is a separate artifact.  Adding a new JS file to `_JS_FILES` requires both `pip install -e .` (so Python sees the new list) and `bristlenose render` (so the static HTML includes it).  In dev mode, only a server restart is needed (uvicorn picks up the Python change, live reload reads the new file)
- **Importer reads people.yaml** — `_import_speakers()` requires `output_dir` parameter to find `people.yaml`. On re-import, `_update_persons_from_people()` only fills empty Person fields — never overwrites non-empty values. This means browser edits survive server restarts
- **Write-through is best-effort** — `_write_through_people_yaml()` in `routes/data.py` logs a warning on failure but doesn't fail the API request. The DB is always updated; YAML update is secondary
- **Codebook tab stale counts on initial load** — the CodebookPanel re-fetches via MutationObserver when its parent `.bn-tab-panel` gains `.active`.  This covers the race where vanilla JS `PUT /tags` hasn't finished when the panel first mounts.  Will be unnecessary once tag writes move from localStorage PUT to React CRUD

## Tests

48 tests in `tests/test_serve_quotes_api.py` (response shape, grouping, field values, researcher state round-trips via data PUT endpoints, speaker name resolution, error handling).  37 happy-path tests in `tests/test_serve_data_api.py`, 57 stress tests in `tests/test_serve_data_api_stress.py`, 43 dashboard tests in `tests/test_serve_dashboard_api.py`, 36 codebook CRUD tests in `tests/test_serve_codebook_api.py`.  All use the smoke-test fixture at `tests/fixtures/smoke-test/input/` which provides:
- 1 project, 1 session (`s1`), 2 speakers (`m1`, `p1`)
- 4 quotes: `q-p1-10` (Dashboard/confusion), `q-p1-26` (Dashboard/frustration), `q-p1-46` (Search/delight), `q-p1-66` (Onboarding/frustration)

Stress tests cover: Unicode (emoji, CJK, RTL, combining chars), large payloads (10 KB edits, 50 tags), rapid sequential PUTs (fast clicking), empty/whitespace values, malformed DOM IDs, duplicate tags and badges (unique constraint dedup), cross-endpoint interactions, and idempotency

### Future: Playwright E2E tests (post-React migration)

After the React migration, Playwright E2E tests will cover the full browser → JS → API → DB path. Currently deferred because E2E tests target DOM selectors which all change during migration. The React components will emit `data-testid` attributes from day one to provide stable selectors. See `docs/design-reactive-ui.md` "Testing strategy" section for the full plan.

## React migration status (updated 17 Feb 2026)

### Primitives (`frontend/src/components/`)

| # | Primitive | Round | Tests | Notes |
|---|-----------|-------|-------|-------|
| 1 | Badge | R1 done | 8 | Sentiment/tag labels, deletable variant |
| 2 | PersonBadge | R1 done | 5 | Speaker code lozenges (p1/m1/o1) |
| 3 | TimecodeLink | R1 done | 6 | Clickable timecodes, player integration |
| 4 | EditableText | R2 done | 19 | Click-to-edit + external trigger modes |
| 5 | Toggle | R2 done | 9 | Star/hide buttons |
| 6 | TagInput | R3 done | 23 | Auto-suggest, ghost text, rapid entry |
| 7 | Sparkline | R3 done | 12 | Mini stacked bars (sentiment distribution) |
| 8 | Counter | R3 done | 14 | Hidden-quotes dropdown (pulled from R4) |
| 9 | Metric | R4 done | 13 | Bar fill + SVG intensity dots, for analysis signal cards |
| 10 | JourneyChain | R4 done | 8 | Arrow-separated labels, wired into SessionsTable |
| 11 | Annotation | R4 done | 14 | Transcript page margin labels, composes Badge |
| 12 | Thumbnail | R4 done | 5 | Sessions table media preview, CSS extracted to atom |
| 13 | MicroBar | M5 done | 12 | Horizontal proportional bar (codebook + analysis) |
| 14 | ConfirmDialog | M5 done | 13 | Contextual inline confirmation, Enter/Escape |
| 15 | Modal | Infra | — | Infrastructure (build when needed for viewport-level dialogs) |
| 16 | Toast | Infra | — | Infrastructure (build when needed for feedback notifications) |

**All 4 rounds + M5 complete (14 primitives + 2 infrastructure, 182 Vitest tests).** Modal and Toast are infrastructure — build when first consumer needs them. ConfirmDialog covers the inline confirmation need that Modal was originally earmarked for.

### Islands (`frontend/src/islands/`)

| Island | Status | Mount point | API |
|--------|--------|-------------|-----|
| SessionsTable | Shipped (M1) | `#bn-sessions-table-root` | `GET /sessions` |
| QuoteSections | Shipped | `#bn-quote-sections-root` | `GET /quotes` |
| QuoteThemes | Shipped | `#bn-quote-themes-root` | `GET /quotes` |
| QuoteCard | Built (internal) | — | (composed into above) |
| QuoteGroup | Built (internal) | — | (composed into above) |
| Dashboard | Shipped (M4) | `#bn-dashboard-root` | `GET /dashboard` |
| CodebookPanel | Shipped (M5) | `#bn-codebook-root` | `GET /codebook` + CRUD |
| AboutDeveloper | Built (dev-only) | `#bn-about-developer-root` | `GET /dev/info` |

### Backend APIs — complete

6 data endpoints (hidden, starred, tags, edits, people, deleted-badges) + sessions + quotes + dashboard + 9 codebook CRUD endpoints. 330+ Python serve tests across 8 files.

### CSS alignment — done through M5

Extracted (R1–R3): `toggle.css`, `editable-text.css`, `sparkline.css`. Renamed: `person-id.css` → `person-badge.css`. Metric reuses existing classes from `organisms/analysis.css`. JourneyChain reuses `.bn-session-journey`. Thumbnail extracted to `atoms/thumbnail.css`. M5 tokenised `codebook-panel.css` (spacing, dark mode merge-target via `color-mix()`, sub-pixel border fix). Added `.confirm-dialog` styles to `codebook-panel.css`.

### What's next

1 remaining infrastructure primitive: **Toast** (build when first feedback notification need arises). Modal is deferred — ConfirmDialog covers inline confirmations. Next islands: transcript page, analysis page.

## AutoCode (LLM-assisted tag application)

`autocode.py` is the engine module. `routes/autocode.py` has 7 API endpoints. Two new ORM tables: `AutoCodeJob` (job lifecycle) and `ProposedTag` (per-quote tag proposals with confidence + rationale).

### How it works

1. Researcher clicks "✦ AutoCode quotes" on a framework separator (e.g. Garrett)
2. `POST /api/projects/{id}/autocode/{framework_id}` → starts background job via `asyncio.create_task()`
3. Engine loads all quotes + codebook discrimination prompts, batches into groups of 25
4. Each batch → one LLM call with full taxonomy (all sub-tags with definition/apply_when/not_this)
5. LLM returns best-fit tag + confidence (0.0-1.0) + rationale per quote — no hard NO_FIT
6. Results stored as `ProposedTag` rows (status: "pending")
7. Frontend polls `/status`, then opens report modal with proposals

### API endpoints

| Method | Path | Purpose |
|--------|------|---------|
| POST | `/projects/{id}/autocode/{framework_id}` | Start job |
| GET | `/projects/{id}/autocode/{framework_id}/status` | Poll progress |
| GET | `/projects/{id}/autocode/{framework_id}/proposals` | List proposals (min_confidence filter) |
| POST | `/projects/{id}/autocode/proposals/{id}/accept` | Accept → creates QuoteTag |
| POST | `/projects/{id}/autocode/proposals/{id}/deny` | Deny → keeps for telemetry |
| POST | `/projects/{id}/autocode/{framework_id}/accept-all` | Bulk accept above threshold |
| POST | `/projects/{id}/autocode/{framework_id}/deny-all` | Bulk deny pending |

### Gotchas

- **Re-run guard**: Unique constraint on `(project_id, framework_id)` — one job per codebook per project. Denied proposals stay for telemetry, not deleted
- **Cloud-only**: Prompt weight ~14K-17K tokens per call. Ollama excluded (4K context can't fit taxonomy + quotes)
- **Background task**: First feature to call LLMs from serve mode. Uses `asyncio.create_task()` — job runs after endpoint returns. No Celery/Redis needed
- **Confidence filter**: Proposals endpoint accepts `min_confidence` query param (default 0.5). All assignments stored regardless, filtered at query time. Stretch goal: user-facing threshold slider
- **LLMClient(settings)**: Takes only settings, creates its own tracker internally. Don't pass LLMUsageTracker as second arg

### Testing

96 tests across 5 files. Live LLM eval harness (`test_autocode_discrimination.py`) has 20 golden Garrett quotes — run with `pytest -m slow` (~$0.01/run, ≥80% accuracy threshold).

## Reference docs

- **Domain model rationale**: `docs/design-serve-milestone-1.md`
- **Migration architecture**: `docs/design-serve-migration.md`
- **React component library** (16 primitives, build sequence, coverage matrix): `docs/design-react-component-library.md` — **read this before building any React component**
- **Codebook island design** (audit, decisions, CSS cleanup): `docs/design-codebook-island.md`
- **React migration plan**: `docs/design-reactive-ui.md`
- **Phase-by-phase walkthrough**: `docs/react-migration-walkthrough.md`
