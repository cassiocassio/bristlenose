# Server & Data API — Context for Claude

## What this is

FastAPI server (`bristlenose serve`) that serves the HTML report, provides REST API endpoints for researcher state, and hosts React islands.  SQLite database stores all pipeline output + researcher edits.

## Architecture

```
bristlenose/server/
  app.py          — FastAPI factory (create_app), dev-mode HTML injection
  db.py           — SQLAlchemy engine, session factory, SQLite with WAL + FK
  models.py       — 22 ORM tables (see docs/design-serve-milestone-1.md)
  importer.py     — Pipeline JSON → SQLite on startup (idempotent upsert)
  admin.py        — SQLAdmin browser (dev-only, /admin/)
  routes/
    health.py     — GET /api/health
    sessions.py   — GET /api/projects/{id}/sessions (React sessions table)
    data.py       — 12 data API endpoints (Phase 1 researcher state sync)
    dev.py        — Dev-only endpoints (visual diff, system info)
  static/         — Vite build output (React islands bundle)
```

## Data API (Phase 1)

The data API replaces localStorage with HTTP.  Each endpoint mirrors one localStorage key.  The vanilla JS modules call `apiPut()` after every `localStorage.setItem()` — fire-and-forget background sync.

### Endpoints

| Method | Path | localStorage key | JS module | DB tables |
|--------|------|------------------|-----------|-----------|
| GET/PUT | `/projects/{id}/people` | `bristlenose-names` | `names.js` | Person, SessionSpeaker |
| GET/PUT | `/projects/{id}/edits` | `bristlenose-edits` | `editing.js` | QuoteEdit, HeadingEdit |
| GET/PUT | `/projects/{id}/tags` | `bristlenose-tags` | `tags.js` | QuoteTag, TagDefinition |
| GET/PUT | `/projects/{id}/hidden` | `bristlenose-hidden` | `hidden.js` | QuoteState |
| GET/PUT | `/projects/{id}/starred` | `bristlenose-starred` | `starred.js` | QuoteState |
| GET/PUT | `/projects/{id}/deleted-badges` | `bristlenose-deleted-badges` | `tags.js` | DeletedBadge |

### Data flow

```
User clicks star → JS updates DOM + in-memory map
                 → localStorage.setItem() (immediate, synchronous)
                 → if (isServeMode()) apiPut('/starred', map) (async, fire-and-forget)
                                        ↓
                                   FastAPI route
                                        ↓
                                   SQLite upsert
```

**localStorage remains the source of truth** for the current page session.  The API is a background sync — if it fails, a toast shows but no rollback occurs.

### Serve-mode detection

The server injects `<script>window.BRISTLENOSE_API_BASE = '/api/projects/1';</script>` into the HTML at serve time (`app.py:_mount_dev_report`).  When absent (static HTML opened from disk), `isServeMode()` returns false and all API calls are silently skipped.

### Quote DOM ID ↔ DB mapping

The static HTML uses DOM IDs like `q-p1-123` (format: `q-{participant_id}-{int(start_timecode)}`).  The API accepts these DOM-style IDs and resolves them server-side:

- **`_parse_dom_quote_id("q-p1-123")`** → `("p1", 123)`
- **`_resolve_quote(db, project_id, "q-p1-123")`** → queries `Quote` where `participant_id="p1"` and `start_timecode` is in `[123, 124)` (the `int()` truncation means we need a range match)

This is in `routes/data.py`.  The same format is generated by `render_html.py` (`f"q-{quote.participant_id}-{int(quote.start_timecode)}"`).

### Bulk maps, not individual PATCH

All endpoints use GET/PUT of full state maps (not per-item PATCH).  This matches the localStorage pattern — each `set()` writes the entire JSON blob.  Tradeoff: larger payloads but simpler migration diff and no partial-state bugs.

### Tag definitions

User-defined tags auto-create `TagDefinition` rows.  New tags are assigned to an "Ungrouped" `CodebookGroup` (auto-created if needed by `_get_or_create_ungrouped()`).  The codebook UI can later reassign them to real groups.

### Hidden + Starred share QuoteState

Both `is_hidden` and `is_starred` live on the same `QuoteState` row (one per quote).  The PUT endpoints update only their respective field — they don't clobber each other.

## api-client.js

The JS-side HTTP abstraction (`bristlenose/theme/js/api-client.js`).  Loaded second in `_JS_FILES` (after `storage.js`, before everything else).

- **`isServeMode()`** — `typeof BRISTLENOSE_API_BASE === 'string'`
- **`apiGet(path)`** — fetch GET, returns JSON or null on error
- **`apiPut(path, data)`** — fetch PUT with JSON body, shows toast on error via `showToast()` (optional dependency from `csv-export.js`)

All calls are **fire-and-forget promises**.  The JS modules don't `await` them.

## Patterns to follow

### Adding a new data endpoint

1. Add the route to `routes/data.py` — follow `get_hidden`/`put_hidden` as the simplest template
2. Use `_get_db(request)`, `_check_project()`, `try/finally db.close()`
3. For quote-keyed data: use `_resolve_quote()` and `_quote_dom_id()` to translate between DOM IDs and DB rows
4. Add tests in `tests/test_serve_data_api.py` — the `client` fixture gives you a TestClient with the smoke-test data pre-imported (4 quotes: `q-p1-10`, `q-p1-26`, `q-p1-46`, `q-p1-66`)
5. If the JS needs to call it: add `if (isServeMode()) apiPut(...)` after the corresponding `store.set()` call

### Adding a new JS module that syncs state

1. Add `isServeMode, apiPut` to the `/* global ... */` comment
2. After every `yourStore.set(data)` call, add: `if (isServeMode()) apiPut('/your-endpoint', data);`
3. That's it.  `apiPut` prepends `BRISTLENOSE_API_BASE` internally — **never** add the base URL at the call site (double-prefix bug)

### DB dependency injection

```python
def _get_db(request: Request) -> Session:
    return request.app.state.db_factory()
```

The factory is stored on `app.state` during `create_app()`.  Each route creates its own session and **must close it** in a `finally` block.

## Dev loop (live JS reload)

In dev mode (`bristlenose serve --dev`), the server **live-reloads JS on every request**.  You can edit any `.js` file in `bristlenose/theme/js/`, refresh the browser, and see the change immediately — no `bristlenose render` step needed.

How it works: `serve_report_html()` reads the baked-in HTML from disk, finds the `/* bristlenose report.js */` marker, and replaces everything from there to the IIFE closing `})();` with freshly-read source files via `_load_live_js()` (which imports `_JS_FILES` from `render_html.py` for the canonical dependency order).  The IIFE wrapper `(function() { ... })();` is part of the Jinja2 template — the replacement must preserve the closing or **all JS init functions silently fail to run** (no console error, just a dead page).

**What still requires re-render:** changes to the Jinja2 HTML template itself (not JS), changes to CSS files, changes to data variables (quote map, analysis data).  JS changes are live.

**Python changes** are handled by uvicorn's `--reload` (WatchFiles) — editing `data.py`, `app.py`, etc. triggers an automatic server restart.

## Gotchas

- **Quote timecode range match** — DOM ID uses `int(start_timecode)` which truncates.  A quote at 123.45s becomes `q-p1-123`.  The resolver queries `start_timecode >= 123 AND start_timecode < 124` to handle this
- **PUT replaces entire state** — PUT `/hidden` with `{}` unhides everything.  PUT `/tags` with `{}` deletes all tags.  This is intentional (mirrors localStorage `setItem`)
- **TagDefinition foreign key** — `codebook_group_id` is non-nullable.  New tags go to the "Ungrouped" group.  Don't use `codebook_group_id=0` — it violates the FK constraint
- **`Session` name collision** — SQLAlchemy's `Session` (the DB session) clashes with the `Session` model.  Import the model as `SessionModel`: `from bristlenose.server.models import Session as SessionModel`
- **`db.close()` in finally** — every route must close its session.  Leaking sessions exhausts the SQLite connection pool
- **Project ID is always 1** — the current server only loads one project at startup.  `BRISTLENOSE_API_BASE` is hardcoded to `/api/projects/1`.  Multi-project support is future work
- **Offline graceful degradation** — static HTML files (opened from disk, not served) have no `BRISTLENOSE_API_BASE` global.  `isServeMode()` returns false, all API calls skip silently, localStorage works as before
- **No `await` on API calls** — the JS modules fire `apiPut()` without awaiting.  This means rapid clicks send multiple overlapping PUTs.  The server handles this safely because each PUT replaces the full state (last writer wins)
- **Ruff ignores JS files** — `ruff check .` skips `.js` files.  Don't pass JS files to ruff directly (it tries to parse them as Python and generates hundreds of false errors)
- **IIFE wrapper around the script block** — `render_html.py` wraps data variables + concatenated JS in `(function() { ... })();`.  The live JS reload (`_replace_baked_js`) must use `rfind("})();")` to preserve the closing.  If you break the IIFE, every init function silently fails — tabs stop working, stars don't toggle, nothing interactive works, but there's **no console error** because the JS simply never executes
- **Baked HTML requires re-render to pick up new JS** — the static HTML report on disk contains a snapshot of the JS from the last `bristlenose render`.  In production (no `--dev`), editing `.js` source files has no effect until you re-render.  The live reload only works in `--dev` mode.  If something works in dev but not in the static file, the static file is stale
- **`pip install -e .` and render are separate steps** — an editable install makes Python changes visible immediately, but the rendered HTML is a separate artifact.  Adding a new JS file to `_JS_FILES` requires both `pip install -e .` (so Python sees the new list) and `bristlenose render` (so the static HTML includes it).  In dev mode, only a server restart is needed (uvicorn picks up the Python change, live reload reads the new file)

## Tests

37 happy-path tests in `tests/test_serve_data_api.py`, 57 stress tests in `tests/test_serve_data_api_stress.py`.  Both use the smoke-test fixture at `tests/fixtures/smoke-test/input/` which provides:
- 1 project, 1 session (`s1`), 2 speakers (`m1`, `p1`)
- 4 quotes: `q-p1-10` (Dashboard/confusion), `q-p1-26` (Dashboard/frustration), `q-p1-46` (Search/delight), `q-p1-66` (Onboarding/frustration)

Stress tests cover: Unicode (emoji, CJK, RTL, combining chars), large payloads (10 KB edits, 50 tags), rapid sequential PUTs (fast clicking), empty/whitespace values, malformed DOM IDs, duplicate tags and badges (unique constraint dedup), cross-endpoint interactions, and idempotency

### Future: Playwright E2E tests (post-React migration)

After the React migration, Playwright E2E tests will cover the full browser → JS → API → DB path. Currently deferred because E2E tests target DOM selectors which all change during migration. The React components will emit `data-testid` attributes from day one to provide stable selectors. See `docs/design-reactive-ui.md` "Testing strategy" section for the full plan.

## Reference docs

- **Domain model rationale**: `docs/design-serve-milestone-1.md`
- **Migration architecture**: `docs/design-serve-migration.md`
- **React migration plan**: `docs/design-reactive-ui.md`
- **Phase-by-phase walkthrough**: `docs/react-migration-walkthrough.md`
